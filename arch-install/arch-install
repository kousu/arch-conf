#!/bin/sh
#
# Install archlinux
# must be *run* from an existing archlinux system.
# You can build a boot disk by downloading the standard installer https://archlinux.org/download/
# and then copying this script to it (via wget, curl, or a spare thumbdrive)
# TODO: or by unpacking + repacking the install image.
#
# Or you can use any existing fully-installed Arch system.

set -e -o pipefail

set -x

usage() {
  echo "usage: $0: /dev/disk"
}

if [ -z "$1" ]; then
  usage
  exit 1
fi

TARGET_DISK="$1"; shift

if [ ! \( -b "$TARGET_DISK" -o -f "$TARGET_DISK" \) ]; then
  echo "error: disk $TARGET_DISK must be a block device or a disk image (a regular file)"
  exit 1
fi

set -u  # NB: set *after* parsing args to make it easier

PARTITION_SCHEME=mbr
# question: can I boot an MBR bootloader on a GPT disk? maybe? GPT disks have a 'protective' MBR, maybe I can put syslinux in there

#
# https://wiki.archlinux.org/title/Installation_guide


# https://wiki.archlinux.org/title/Installation_guide#Partition_the_disks
#
# An assumption is that we only have one disk -- you can always format more disks after installation.
# Exotic setups involving having your OS on LVM/RAID are out of scope.

# TODO:
# - [ ] support detecting file type -- use a loop mount if a regular file
# - [ ] adapt partition layout to the given disk size / according
# - [ ] make swap optional
# - [ ] encrypt the disk
#   - [ ] make encryption optional
#   - [ ] make integrity optional / add warning about how slow it is to wipe the entire disk
# - [ ] make swap use a stable encryption key so that hibernation works
# - [ ] somehow take device-nigiri as an option to install
# - [ ] take the hostname on the command line
#   - does the system work without /etc/hostname and /etc/localtime and /etc/locale.conf? can i skip them?
#  the entire thing should be unattended once you're past: connect to the wifi, tell it what packages to bootstrap with?
#  maybe i should 
# - [ ] thumbdrive 'shared drive' mode (incompatible with GPT mode??)
# - [ ] GPT mode
# - [ ] disable MBR bootloader
# - [ ] disable EFI bootloader
#   the bootloaders are so damn finicky
# - [ ] when in MBR mode: only use the extended partition if given more than 4 partitions
# - [ ] 

( # this subshell for the benefit of the possible trap EXIT

if [ -f "$TARGET_DISK" ]; then
  TARGET_DISK="$(losetup --show -f "$TARGET_DISK")"
  trap 'losetup -d "$TARGET_DISK"' EXIT # 'EXIT' is a XXX bashism
  # also this means only one cleanup is possible
fi

sfdisk "$TARGET_DISK" <<EOF
label: dos

# make a single extended partition to cover the whole disk
# an extended partition covers everything.
type=extended

# thumbdrive mode: share partition, which should be readable by most systems
size=8G, type=c
#size=8M, type=c

# ESP and also /boot
# note: /boot doesn't *have* to be a separate partition: syslinux in MBR mode and grub are both capable of finding and booting directly from /
#  but in that case you can't make / encrypted
size=1G, type=uefi, name="/boot", bootable
#size=256M, type=uefi, name="/boot", bootable

# type=linux is the default for the rest
size=31G, name="/"
#size=10G, name="/"
size=2G,  type=swap, name="swap"
name="/home"
# last partition => takes the rest of the space
EOF

echo $?  # DEBUG

losetup -l  # DEBUG

ls /dev/loop*  #DEBUG
partprobe "$TARGET_DISK" # possibly redundant? sfdisk should do this, but doesn't in some cases?
ls /dev/loop*  # DEBUG

# maybe I can just hardcode the partition names for the moment

# but there's the rub: I don't know how sfdisk will lay out the partitions...
# well actually I do: everything after the extended partition starts numbering at 5


# https://wiki.archlinux.org/title/Installation_guide#Format_the_partitions

# goddammit fucking things

mkfs.msdos -n "partage" "$TARGET_DISK"p5
#mkfs.msdos -n "partage" "$TARGET_DISK"5
mkfs.msdos -n "boot" "$TARGET_DISK"p6 # should be -n /boot but / isn't allowed on FAT
#mkfs.msdos -n "boot" "$TARGET_DISK"6 # should be -n /boot but / isn't allowed on FAT
mkfs.ext4 -L "/" "$TARGET_DISK"p7
#mkfs.ext4 -L "/" "$TARGET_DISK"7
mkswap "$TARGET_DISK"p8
mkfs.ext4 -L "/home" "$TARGET_DISK"p9
#mkfs.ext4 -L "/home" "$TARGET_DISK"8

# TODO:
#cryptsetup "$TARGET_DISK"
#mkfs.dos -n "partage" "$TARGET_DISK"p2
#mkfs.dos -n "partage" "$TARGET_DISK"p2
#mkfs.dos -n "partage" "$TARGET_DISK"p2
#mkfs.dos -n "partage" "$TARGET_DISK"p2




# okay whatever let's just see how far i can go without root
# and then decide if maybe that was dumb as fuck
# I need to find what sector each partition is on right?

# to work out:
# - [ ] loop devices get 'p' injected to their partitiondevices (/dev/loop0p2) but sd devices don't...
# - [ ] get cryptsetup involved
# - [ ] make grub/syslinux a flag
# - [ ] make mbr/efi a flag (or, each a separate option)

(
#OUTER_SWAPS=$(genfstab -U / | awk '$3 == "swap"')
#OUTER_SWAPS=$(genfstab -U / | grep swap) # XXX this will catch any mountpoints named 'swap'
OUTER_SWAPS=$(genfstab -U /)

swapon "$TARGET_DISK"p8
trap 'swapoff "$TARGET_DISK"p8' EXIT

(
# https://wiki.archlinux.org/title/Installation_guide#Mount_the_file_systems
CHROOT="$(mktemp -d -t "arch-root-XXXXXXXXX")" # the installation guide says to use /mnt, but since this might be run from a working system, make an isolated mountpoint
trap 'umount -v -R "$CHROOT"; rmdir -v "$CHROOT"' EXIT

# from this point on things must be done as root...

mount "$TARGET_DISK"p7 "$CHROOT"
#mount "$TARGET_DISK"7 "$CHROOT"
# careful here: the order of mounts needs to be aware of what filesystems nest inside what others
# because we need to mkdir the mountpoints on each point properly...
mkdir -p "$CHROOT""/home" # like, we wanna make sure this is owned by root
mount "$TARGET_DISK"p9 "$CHROOT""/home" # this too...
#mount "$TARGET_DISK"9 "$CHROOT""/home" # this too...

mkdir -p "$CHROOT""/boot"
mount "$TARGET_DISK"p6 "$CHROOT""/boot"
#mount "$TARGET_DISK"6 "$CHROOT""/boot"

# https://wiki.archlinux.org/title/Installation_guide#Installation

# https://wiki.archlinux.org/title/Installation_guide#Connect_to_the_internet
# Connecting to the net can't be automated -- easily
# TODO: scan for ethernet portsBecause connecting to the net 
if ! ping -c 3 archlinux.org >/dev/null; then
  echo "error: network failure. Are you online? Follow https://wiki.archlinux.org/title/Installation_guide#Connect_to_the_internet" >&2
  exit 1
fi

# ^ maybe this can...wait? until we get down to actually installing the system? idk
#

# https://wiki.archlinux.org/title/Installation_guide#Update_the_system_clock
# set the time so that https:// mirrors will work.
# if this script is *not* run as root, skip; the clock is _probably_ right,
# especially if running as non-root which implies we're being run from a standard Arch system on athis step
if [ "$EUID" -eq 0 ]; then
  timedatectl set-ntp true
fi

pacstrap -c -G -M "$CHROOT" base linux linux-firmware
pacstrap -c -G -M "$CHROOT" syslinux
#pacstrap -c -G -M "$CHROOT" grub
pacstrap -c -G -M "$CHROOT" intel-ucode amd-ucode # microcode updates: https://wiki.archlinux.org/title/Microcode
pacstrap -c -G -M "$CHROOT" sudo # XXX this should really be handled by..the..other..thing.

## 
pacstrap -c -G -M "$CHROOT" vi iwd iproute2 # DEBUG
arch-chroot "$CHROOT" tee /etc/systemd/network/wired.network <<EOF
[Match]
Name=*

[Network]
DHCP=yes
EOF
arch-chroot "$CHROOT" systemctl enable systemd-networkd systemd-resolved iwd
# -G == don't copy installer's archlinux-keyring
# -M == 'don't copy mirrorlist'; instead, bootstrap it using reflector:
# these are to prevent leakage from the installer into the installed system.
# (the installed system can/should use reflector periodically to adapt its mirrors; especially, it should use --country)
#reflector --score 10 -f 3 --save "$CHROOT"/etc/pacman.d/mirrorlist
reflector --score 10 --save "$CHROOT"/etc/pacman.d/mirrorlist

# https://wiki.archlinux.org/title/Installation_guide#Fstab

# This is where it gets especially fiddly
# because I additionally need to setup /etc/crypttab
# NB: uses -U so mountpoints are found by UUID, which should make them insensitive to be

# workaround: genfstab will include swap *from the outer system*
# this isn't an issue if using the default Arch install image, because that has no swap
# but just in case: figure out what swap is from the outer system
#  `grep -vxF -f` does set subtraction and is a wild command courtesy of https://catonmat.net/set-operations-in-unix-shell

genfstab -U "$CHROOT" | grep -vxF -f <(echo "$OUTER_SWAPS") >> "$CHROOT"/etc/fstab


# https://wiki.archlinux.org/title/Installation_guide#Boot_loader

# MBR: https://wiki.archlinux.org/title/Syslinux#Automatic_install
arch-chroot "$CHROOT" syslinux-install_update -i -a -m
#arch-chroot "$CHROOT" grub-install --target=i386-pc "$TARGET_DISK"

# EFI: https://wiki.archlinux.org/title/Syslinux#Installation_on_UEFI
# $ESP/efi/boot/bootx64.efi is a well known path that most EFI systems
# caveats:
#  - some systems have 32 bit EFIs; they need to start from $ESP/efi/boot/bootx32.efi and to load the binaries from
#     /usr/lib/syslinux/efi32/ (and it's not just syslinux.efi in there!)
#    this will not work at all for 32 bit EFI hardware
#    notably: 2007 macbooks are like this, and some
arch-chroot "$CHROOT" mkdir -p /boot/efi/boot # this is a Well Known Path; if you use any other path, you need to use efibootmgr to tell the firmware about it, and then the disk will not be booatable on other hardware
arch-chroot "$CHROOT" cp -r /usr/lib/syslinux/efi64/* /boot/efi/boot
arch-chroot "$CHROOT" mv /boot/efi/boot/{syslinux,bootx64}.efi # use the Well Known Path

#arch-chroot "$CHROOT" grub-install --target=x86_64-efi --efi-directory=/boot/ --bootloader-id=GRUB --removable
#arch-chroot "$CHROOT" grub-install --target=i386-efi --efi-directory=/boot/ --bootloader-id=GRUB --removable
#arch-chroot "$CHROOT" grub-mkconfig -o /boot/grub/grub.cfg

# now the really tricky part: setting up the kernel arguments
# syslinux installs with root=/dev/sda3 as a default; replace with with the UUID of the real root for portability
# get the root disk so we can tell the bootloader about it
ROOT_UUID="$(genfstab -U "$CHROOT" | awk '$2 == "/" { print $1 }')"
# -> this could also be extracted with lsblk and findmnt -- that's what genfstab uses internally -- but this is shorter and guaranteed to match fstab
arch-chroot "$CHROOT" sed -i 's/root=[^ ]\+/root='"$ROOT_UUID"'/' /boot/syslinux/syslinux.cfg

#read -p "check your goddamn work in $CHROOT"
# https://wiki.archlinux.org/title/Microcode#Early_loading ( optional - without this the system *will still boot* and *will still use microcode updates*, it's just that the boot process itself won't. This ..shouldn't matter, unless you have some really glitchy and broken system.)
# also, if these packages aren't installed..then...just...nothing happens? I think?
arch-chroot "$CHROOT" sed -i 's|INITRD |INITRD ../amd-ucode.img,../intel-ucode.img,|' /boot/syslinux/syslinux.cfg

# MBR .cfg -> EFI .cfg (they should be almost identical)
arch-chroot "$CHROOT" cp /boot/{syslinux,efi/boot}/syslinux.cfg

# except the paths are slightly different:
# the EFI is one level deeper than syslinux's usual default
arch-chroot "$CHROOT" sed -i 's|../|../../|g' /boot/efi/boot/syslinux.cfg


# the other parts of https://wiki.archlinux.org/title/Installation_guide#Configure_the_system
# are covered by my arch-conf package

## and then there's the tricky credentials part:
# - the root passwd
# - making a user account
# - granting that user sudo / other relevant groups / rights

# To log in: just type 'root' but then you're immediately forced to set a password.
arch-chroot "$CHROOT" passwd -de root

if [ -n "$SUDO_USER" ]; then
  # add an admin account, with the same name as the calling user
  # (this is kind of janky)
  arch-chroot "$CHROOT" useradd -m -G wheel,disk,network,lp $SUDO_USER
  arch-chroot "$CHROOT" passwd -de $SUDO_USER
fi

# https://wiki.archlinux.org/title/Installation_guide#Reboot

) # -> trap 'umount -R "$CHROOT"' EXIT

) # -> trap 'swapoff "$TARGET_DISK"p8' EXIT

) # -> trap 'losetup -d ...' EXIT 
