pkgname=kousu-base
pkgdesc="Configuration management for kousu"
arch=('any')
url="https://github.com/kousu/arch-conf"

_pkgver() {
  [ -r "$startdir"/.pkgver ] && cat "$startdir"/.pkgver || (echo "r$(git rev-list --count HEAD).commit=$(git describe --always --dirty | sed s/-/+/g)")
}
pkgver="$(_pkgver)"
pkgrel=1

depends=(
  # Base system
  base
  man-db # the 'man' command
  man-pages # the core linux man pages (kernel, libc, file formats)
  reflector # for updating /etc/pacman.d/mirrorlist
  etckeeper # for tracking /etc/'s changes; (this is redundant with this package itself; but it's a useful redundancy, that helps me figure out what to change)
  pacman-contrib # pactree, pacdiff, etc
  devtools       # makechrootpkg, pkgctl, etc

  # hardware
  linux  # the kernel. on Arch, this is an *optional* package, so that you can install vanilla Arch inside a container.
  dmidecode # reads low-level BIOS information
  hwinfo
  intel-ucode
  amd-ucode # TODO: these two packages have an optional but difficult amount of manaul setup:
            # https://wiki.archlinux.org/title/Microcode#Early_loading
            # basically you need to edit your kernel command line to *prepend* initrd=/boot/amd-ucode.img,/boot/intel-ucode.img,
            # and making that edit by script is tricky. and also in the early boot that path is not always at /boot? ai yi yi
  usbutils

  lvm2
  e2fsprogs
  dosfstools

  sysstat   # iostat, some other things..
  hdparm
  lshw
  lsof
  iftop
  iotop
  powertop
  nethogs
  net-tools # netstat, ifconfig
  #inetutils # for hostname(1); also has telnet(1), rsh(1), and other deprecated commands
  strace

  # CLI
  bash-completion  # lets apps customize tab completion; it's handy for pass(1) and kubectl(1) and some others, but intereferes and is annoying when apps provide incomplete tab completion because it *disables* the default behaviour of files.
  sudo

  # CLI :: Files
  restic
  fdupes
  magic-wormhole

  # CLI :: Network
  openbsd-netcat
  wireguard-tools
  openssh
  innernet
  socat
  rsync
  sshfs
  bind      # for dig
  whois
  tcpdump
  nmap
  geoip
  geoip-database-extra

  # CLI :: Programming
  base-devel
  words

  git
  git-filter-repo
  #git-lfs
  #git-annex

  # archivers
  7zip
  cdrtools
  unrar
  zip
  unzip

  python
  python-pip
  python-wheel
  python-build

  #nodejs
  #npm

  jq
  htmlq

  strip-nondeterminism
  parallel

  # TUI
  vis    # editor
  lua-lpeg # syntax highlighting in vis
  #vim
  #e3    # has e3vi; 23kiB installed

  htop   # resource/process monitor
)

# `source` has some basic support for handling local files
# but it expects them to all be in the top-level folder. It's not really meant for bundling an entire directory tree,
# and to handle a directory tree it expects to be given a .tar to extract into src/
# Instead, I've committed the contents of this package *directly* to src/.

install="${pkgname}.install"

backup=(
  # user-editable config files
  etc/.gitignore
  etc/gitconfig
  etc/locale.conf
)

package() {
  cd "${startdir}/src/"   # instead of prepare() { cp "${startdir}/src/." "${srcdir}" }

  # often PKGBUILDs use install(1) here, because it lets them control permissions
  # but install(1) can't do folders recursively; so instead, just cp -r, and set any permissions directly with chmod
  # that's safe enough: this is *building* a package for later deployment, not installing on a live system where a temporary gap in permissions is a risk
  cp -rp * "${pkgdir}"

  chmod 750 "${pkgdir}"/etc/sudoers.d
  chmod 600 "${pkgdir}"/etc/sudoers.d/*
}
